\thispagestyle{abstractpagestyle}

\vspace*{36pt}

\begin{center}
    \textbf{\fontsize{20pt}{24pt} \selectfont ABSTRACT}
\end{center}

\vspace{24pt}

The reverse engineering tool developed in this project is a sophisticated software suite designed to decompile binaries in multiple formats and from different processor architectures into a high-level, domain-specific language that can be easily analyzed and understood by humans. With the ability to detect bugs, analyze malicious executables, and perform static analysis of code for optimization purposes, this tool has broad applications for software developers, security researchers, and computer engineers. It is important to note that the tool is intended for ethical and lawful uses only and will not be utilized for any malicious activities. By leveraging state-of-the-art decompiling techniques, this tool has the potential to unlock insights into the workings of complex software systems that were previously difficult to obtain.
\paragraph{}
This tool comprises three main modules, each contributing to the overall high-level design. The first module, the "lifter," is responsible for converting raw binary code in formats like ELF, PE, or Mach-O, which have been compiled on different architectures such as x86 or ARM, to LLVM intermediate representation (IR), generating a low-level control flow graph (CFG). The second module, the "universal decompiling machine," performs both data flow analysis and control flow analysis on the CFG generated by the lifter. During data flow analysis, the tool applies optimizations such as dead code elimination, loop simplification, Sparse Conditional Constant Propagation (SCCP), and instruction combination. Additionally, the tool uses interval analysis to detect loops, enabling the identification of opportunities for further optimization. The output of this stage includes the CFG as well as information on loops, loop types, conditionals, variable types, functions, and more. Finally, the "code generation" module combines the CFG with the information gathered from the previous stages to produce an equivalent version of the code in the project's domain-specific language, which is designed to be easily understandable by humans.

\vfill