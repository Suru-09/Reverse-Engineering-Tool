diff --git a/include/codeGen/CodeGeneration.h b/include/codeGen/CodeGeneration.h
index 0d7163b..f9739dc 100644
--- a/include/codeGen/CodeGeneration.h
+++ b/include/codeGen/CodeGeneration.h
@@ -6,14 +6,15 @@
 #include <memory>
 #include <map>
 
+#include "codeGen/instructions/Instruction.h"
 #include "udm/FuncInfo.h"
 
 #include "spdlog/spdlog.h"
 
 #include "llvm/IR/Function.h"
 #include "llvm/IR/Instruction.h"
+#include "llvm/IR/BasicBlock.h"
 
-#include "codeGen/instructions/Instruction.h"
 
 namespace codeGen {
 
@@ -28,6 +29,10 @@ private:
     std::string expandInstruction(llvm::Instruction* instr, int numSpaces);
     bool isValueSubstring(const std::string& value);
 
+    std::unordered_map<std::string, uint64_t> noOfUses(llvm::Function& f);
+    std::string generateConditionalBranch(llvm::BasicBlock* bb, int numSpaces, const udm::FuncInfo& funcInfo);
+    std::string generateLoop(llvm::BasicBlock* bb, int numSpaces, const udm::FuncInfo& funcInfo);
+
     std::string irFile;
     std::unordered_map<std::string, udm::FuncInfo> funcInfoMap;
     std::unordered_map<std::string, std::string> decompiledFunctions;
diff --git a/include/codeGen/LoopGen.h b/include/codeGen/LoopGen.h
index 6e96a9b..112844b 100644
--- a/include/codeGen/LoopGen.h
+++ b/include/codeGen/LoopGen.h
@@ -13,7 +13,7 @@ public:
     LoopGen() = default;
     ~LoopGen() = default;
 
-    static std::string generateLoop(std::shared_ptr<Instruction> instr, int numSpaces, udm::BBInfo::LoopType loopType);
+    static std::string generateLoop(const std::string& condition, int numSpaces, udm::BBInfo::LoopType loopType);
 };
 
 }   // namespace codeGen
diff --git a/src/codeGen/CodeGeneration.cpp b/src/codeGen/CodeGeneration.cpp
index 85f2bb2..95b368b 100644
--- a/src/codeGen/CodeGeneration.cpp
+++ b/src/codeGen/CodeGeneration.cpp
@@ -63,51 +63,25 @@ void codeGen::CodeGeneration::processFunction(llvm::Function& f, const udm::Func
 
     std::string decompiledFunction = "\n" + generateFnHeader(f);
     uint64_t numSpaces = 4, numSpacesForBlock = 4;
-
-    auto appendInstrToDecompFN = [&](llvm::Instruction& inst, uint64_t numSpaces)
-    {
-        auto instr = codeGen::Instruction::getInstruction(inst, numSpaces);
-        if(instr)
-        {
-            decompiledFunction += instr->toString();
-        }
-    };
-
-    uint64_t counter = 0;
-    const std::string var = "var";
     std::stack<std::string> bbStack;
     std::vector<std::string> visited;
 
     bool printFirstInst = true, printLastInst = true;
 
     llvm::ReversePostOrderTraversal<llvm::Function*> rpot(&f);
+    auto uses = noOfUses(f);
     for(auto& bb: rpot)
     {
-        // for(auto& inst: *bb)
-        // {
-        //     inst.setName(var + std::to_string(counter++));
-        // }
-
         auto bbName = bb->getName().str();
         auto bbInfo = funcInfo.getBBInfo(bbName);
         logger->info("Basic block: {}", bb->getName());
         logger->error("BB Info: {}", bbInfo.toString());
 
+
         // generate conditional branch
-        if(bbInfo.getLoopType() == udm::BBInfo::LoopType::NONE && !bbInfo.getFollowNode().empty())
+        std::string branchString = generateConditionalBranch(bb, numSpaces, funcInfo);
+        if(!branchString.empty())
         {
-            auto instr = codeGen::Instruction::getInstruction(bb->front(), numSpaces);
-            
-            std::string branchString = "";
-            if(!bbStack.empty() && bbName == bbStack.top())
-            {
-                branchString = codeGen::BranchConditionalGen::generateConditional(instr, numSpaces, false);
-            }
-            else
-            {
-                branchString = codeGen::BranchConditionalGen::generateConditional(instr, numSpaces, false);
-            }
-            
             bbStack.push(bbInfo.getFollowNode());
             decompiledFunction += branchString;
             numSpaces += numSpacesForBlock;
@@ -115,18 +89,15 @@ void codeGen::CodeGeneration::processFunction(llvm::Function& f, const udm::Func
         }
 
         // generate loop
-        if(bbInfo.getLoopType() != udm::BBInfo::LoopType::NONE)
+        std::string loopString = generateLoop(bb, numSpaces, funcInfo);
+        if(!loopString.empty())
         {
-            auto instr = codeGen::Instruction::getInstruction(bb->back(), numSpaces);
-
-            std::string loopString = codeGen::LoopGen::generateLoop(instr, numSpaces, bbInfo.getLoopType());
             decompiledFunction += loopString;
             numSpaces += numSpacesForBlock;
             bbStack.push(bbInfo.getFollowNode());
             printFirstInst = false;
         }
 
-
         while(!bbStack.empty() && bbName == bbStack.top())
         {
             logger->error("Equality: {} == {} -> [{}]", bbName, bbStack.top(), bbName == bbStack.top());
@@ -147,11 +118,11 @@ void codeGen::CodeGeneration::processFunction(llvm::Function& f, const udm::Func
             }
 
           
-            if(!printFirstInst)
-            {
-                printFirstInst = true;
-                continue;
-            }
+            // if(!printFirstInst)
+            // {
+            //     printFirstInst = true;
+            //     continue;
+            // }
             
             if(instruction)
             {
@@ -167,7 +138,7 @@ void codeGen::CodeGeneration::processFunction(llvm::Function& f, const udm::Func
 
         for(auto& [key, value]: instructionMap)
         {
-            if(!isValueSubstring(value) && std::find(visited.begin(), visited.end(), key) == visited.end())
+            if(!isValueSubstring(value) && std::find(visited.begin(), visited.end(), key) == visited.end() && uses[key] > 1)
             {
                 decompiledFunction += utils::CodeGenUtils::getSpaces(numSpaces);
                 decompiledFunction += key + " = " + value;
@@ -211,6 +182,41 @@ bool codeGen::CodeGeneration::isValueSubstring(const std::string& value)
     return false;
 }
 
+std::string codeGen::CodeGeneration::generateConditionalBranch(llvm::BasicBlock* bb, int numSpaces, const udm::FuncInfo& funcInfo)
+{
+    std::string result = "";
+    auto bbInfo = funcInfo.getBBInfo(bb->getName().str());
+
+    if(bbInfo.getLoopType() == udm::BBInfo::LoopType::NONE && !bbInfo.getFollowNode().empty())
+    {
+        auto instr = codeGen::Instruction::getInstruction(bb->front(), numSpaces);
+        if(instr)
+        {
+            result += codeGen::BranchConditionalGen::generateConditional(instr, numSpaces, false);
+        }
+    }
+    return result;
+}
+
+std::string codeGen::CodeGeneration::generateLoop(llvm::BasicBlock* bb, int numSpaces, const udm::FuncInfo& funcInfo)
+{
+    std::string result = "";
+    auto loopType = funcInfo.getBBInfo(bb->getName().str()).getLoopType();
+    if(loopType == udm::BBInfo::LoopType::NONE)
+    {
+        return result;
+    }
+
+    auto expandedInstr = expandInstruction(&bb->back(), 0);
+    if(expandedInstr.empty())
+    {
+        return result;
+    }
+
+    result += codeGen::LoopGen::generateLoop(expandedInstr, numSpaces, loopType);
+    return result;
+}
+
 std::string codeGen::CodeGeneration::generateFnHeader(llvm::Function& f)
 {
     std::string result = "";
@@ -236,6 +242,34 @@ std::string codeGen::CodeGeneration::generateFnHeader(llvm::Function& f)
     return result;
 }
 
+std::unordered_map<std::string, uint64_t> codeGen::CodeGeneration::noOfUses(llvm::Function& f)
+{
+    std::unordered_map<std::string, uint64_t> result;
+    auto rpot = llvm::ReversePostOrderTraversal<llvm::Function*>(&f);
+    for(auto& bb: rpot)
+    {
+        for(auto& inst: *bb)
+        {
+            for(auto& op: inst.operands())
+            {
+                if(op->hasName())
+                {
+                    auto opName = op->getName().str();
+                    if(result.find(opName) == result.end())
+                    {
+                        result.insert_or_assign(opName, 1);
+                    }
+                    else
+                    {
+                        result[opName]++;
+                    }
+                }
+            }
+        }
+    }
+    return result;
+}
+
 std::string codeGen::CodeGeneration::expandInstruction(llvm::Instruction* instr, int numSpaces)
 {
     std::string instrName = instr->getName().str();
diff --git a/src/codeGen/LoopGen.cpp b/src/codeGen/LoopGen.cpp
index f26c280..6e1b827 100644
--- a/src/codeGen/LoopGen.cpp
+++ b/src/codeGen/LoopGen.cpp
@@ -4,10 +4,9 @@
 #include <iostream>
 #include <memory>
 
-std::string codeGen::LoopGen::generateLoop(std::shared_ptr<Instruction> instr, int numSpaces, udm::BBInfo::LoopType loopType)
+std::string codeGen::LoopGen::generateLoop(const std::string& condition, int numSpaces, udm::BBInfo::LoopType loopType)
 {
    std::string result = utils::CodeGenUtils::getSpaces(numSpaces);
-   std::string condition = instr->toString();
    
     if(loopType == udm::BBInfo::LoopType::WHILE)
     {
